/* compressDictionary.cpp
   Copyright (C) 2007, Rodrigo Gonzalez, all rights reserved.
   Copyright (C) 2008, Francisco Claude.

   compressDictionary

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

/* This file is basically Rodrigo Gonzalez's implementation for the
 * dictionary representation of the compressed suffix array based on
 * Re-Pair, I just added some functions to compute structures that
 * couldn't be generated by the approximate Re-Pair on the flight and
 * some extra code for dumping the result.
 */

#include <iostream>
#include <errno.h>
#include <cassert>
#include "basic.h"
#include "bitrankw32int.h"
#include "util.h"

using namespace std;

uint *symbols_pair;
uint *symbols_new_bit;
uint  symbols_new_bit_len;
uint *symbols;
uint n,m,nbits;

BitRankW32Int *BRR;              //bitmap to indicate the structure of symbols_new
BitRankW32Int *BR;
uint *symbols_new;               // table to decompress de new codes
uint  symbols_new_len;           // len of symbols_new
uint min_value;
uint max_value;
uint max_assigned;

void  new_value(uint *symbols_pair,uint *symbols_new_value,uint *k1,uint *j,uint pos);

uint pos;

void unroll(uint s, int i) {
    if(s>max_value) {
        unroll(symbols_pair[2*(s-max_value-1)],i);
        unroll(symbols_pair[1+2*(s-max_value-1)],i);
        return;
    }
    pos++;
}


void fillBR(uint * bits) {
    pos = 0;
    for(uint i=0;i<m;i++) {
        bitset(bits,pos);
        unroll(symbols[i],i);
    }
}


void fillBR2() {
    uint bits_BR_len = (n+2);
    uint * bits_BR = (uint*)malloc(sizeof(uint)*((bits_BR_len+W-1)/W));
    for(uint i=0; i<(W-1+bits_BR_len)/W;i++)
        bits_BR[i]=0;

    fillBR(bits_BR);
    bitset(bits_BR,pos);
    BR = new BitRankW32Int(bits_BR, bits_BR_len , true, 20);
}


void compress_pair_table() {
    uint aux,j,i;
    /* Compress table of pairs */
    fillBR2();
    uint *symbols_pair_tmp = (uint*) malloc(sizeof(uint)*(max_assigned-max_value));
    for (i =0 ; i< (max_assigned-max_value) ; i++)
        symbols_pair_tmp[i]=0;

    for (i =0 ; i< (max_assigned-max_value) ; i++) {
        aux=symbols_pair[2*i];
        if (aux > max_value) {
            symbols_pair_tmp[aux-max_value-1]++;
        }
        aux=symbols_pair[2*i+1];
        if (aux > max_value) {
            symbols_pair_tmp[aux-max_value-1]++;
        }
    }
    j=0;
    for (i =0 ; i< (max_assigned-max_value); i++) {
        if (symbols_pair_tmp[i] != 0)
            j++;
    }

    symbols_new_len = 2*(max_assigned-max_value)-j;
    symbols_new = (uint*) malloc(sizeof(uint)*(symbols_new_len));
    symbols_new_bit = (uint*) malloc(sizeof(uint)*((symbols_new_len+(max_assigned-max_value))/32+1));
    uint *symbols_new_value = (uint*) malloc(sizeof(uint)*(max_assigned-max_value));
    assert(symbols_new_value!=NULL);

    for (i =0 ; i<((symbols_new_len+(max_assigned-max_value))/32+1);i++)
        symbols_new_bit[i]=0;
    for (i =0 ; i<symbols_new_len;i++)
        symbols_new[i]=0;
    for (i =0 ; i<(max_assigned-max_value);i++)
        symbols_new_value[i]=0;
    j=1;
    uint k1=0;
    for (i =0 ; i< (max_assigned-max_value) ; i++) {
        if (symbols_pair_tmp[i] == 0) {
            symbols_new_value[i]=j; bitset(symbols_new_bit,j-1); j++;
            new_value(symbols_pair,symbols_new_value,&k1,&j,i);
        }
    }
    symbols_new_bit_len = j;
    uint *symbols_new_bit_aux = new uint [(symbols_new_bit_len/32+1)];
    assert(symbols_new_bit_aux!=NULL);

    for (i =0 ; i<symbols_new_bit_len/32+1;i++) {
        symbols_new_bit_aux[i]= symbols_new_bit[i];
    }
    free(symbols_new_bit);
    symbols_new_bit=symbols_new_bit_aux;

    /* Solo para verificar */
    //for (i =0 ; i<(max_assigned-max_value);i++)
    //if (symbols_new_value[i]==0) printf("s[%lu]=%lu, frec=%lu\n",i,symbols_new_value[i], symbols_pair_tmp[i]);

    free(symbols_pair_tmp);
    uint cuentame=0,cuentame2=0,distancia=0;
    double maximo=0;
    nbits=bits(symbols_new_bit_len+max_value+1);
    uint *symbols_aux = (uint *) malloc(sizeof(uint)*((m/32*nbits + m%32*nbits/32)+1));
    assert(symbols_aux!=NULL);
    for (i =0 ; i< m ; i++) {
        aux = symbols[i];
        if (aux > max_value) {
            SetField(symbols_aux,nbits,i,symbols_new_value[aux-max_value-1]+max_value);
            //symbols[i] = symbols_new_value[aux-max_value-1]+max_value;
            /*if(i>=18412900)
              printf("i=%u aux=%u\n",i,aux); fflush(stdout);*/
            distancia+=BR->select(i+2)-BR->select(i+1);
            cuentame2++;
        }
        else {
            SetField(symbols_aux,nbits,i,aux);
            maximo+=distancia*distancia;
            distancia=0;maximo++;
            cuentame++;
        }
    }
    free(symbols);
    symbols=symbols_aux;

    /* Compact symbols_new */
    /*
    symbols_aux = (uint *) malloc(sizeof(uint)*((symbols_new_len*nbits)/32+1));
    for (i =0 ; i< symbols_new_len ; i++) {
      SetField(symbols_aux,nbits,i,symbols_new[i]);
    }
    free(symbols_new);
    symbols_new=symbols_aux;
    */

    free(symbols_new_value);
    free(symbols_pair);
    BRR=new BitRankW32Int(symbols_new_bit, symbols_new_bit_len , true, 20);

    /*printf("Sin Comprimir=%u, comprimido=%u\n",cuentame,cuentame2);
    printf("Costo prom descompr=%f\n",maximo/(float)n);
    printf("Original=%u\n",n);
    printf("Simpolos finales=%u (%.6f%%)\n",m,m/(float)n*100);
    printf("Conjunto de pares=%u (%.6f%%) hubo %u reemplazos\n",2*(max_assigned-max_value),(2*(max_assigned-max_value))/(float)n*100,(max_assigned-max_value));
    aux=symbols_new_bit_len/32+1;
    printf("Conjunto de pares2=%u+%u (%.6f%%) ahorro  %u\n",symbols_new_len,aux,(symbols_new_len+aux)/(float)n*100,2*(max_assigned-max_value)-symbols_new_len-aux);
    printf("Estructura para rank para descomprimir=%u (%.6f%%) tira de bits+5%% extra \n",((n)/32)+1+(((n)/32)+1)*5/100,(((n)/32)+1+(((n)/32)+1)*5/100)/(float)n*100);
    printf("Sumas simbolos+pares=%u (%.6f%%)\n",m+2*(max_assigned-max_value),(m+2*(max_assigned-max_value))/(float)n*100);
    printf("Sumas simbolos+pares2=%u (%.6f%%)\n",m+symbols_new_len+aux,(m+symbols_new_len+aux)/(float)n*100);*/
}


void  new_value(uint *symbols_pair,uint *symbols_new_value,uint *k1,uint *j,uint pos) {
    uint izq,der;
    izq=symbols_pair[2*pos];
    der=symbols_pair[2*pos+1];

    if (izq>max_value) {
        izq=izq-max_value-1;
        if (symbols_new_value[izq] == 0) {
            symbols_new_value[izq]=*j; bitset(symbols_new_bit,*j-1); (*j)++;
            new_value(symbols_pair,symbols_new_value,k1,j,izq);
        }
        else {
            symbols_new[*k1]=symbols_new_value[izq]+max_value; (*j)++; (*k1)++;
        }
    }
    else {
        symbols_new[*k1]=izq;(*j)++;(*k1)++;
    }

    if (der>max_value) {
        der=der-max_value-1;
        if (symbols_new_value[der] == 0) {
            symbols_new_value[der]=*j; bitset(symbols_new_bit,*j-1); (*j)++;
            new_value(symbols_pair,symbols_new_value,k1,j,der);
        }
        else {
            symbols_new[*k1]=symbols_new_value[der]+max_value; (*j)++; (*k1)++;
        }
    }
    else {
        symbols_new[*k1]=der;(*j)++;(*k1)++;
    }

}


int main(int argc, char ** argv) {
    if(argc<2) {
        printf("Usage: %s <graph>\n",argv[0]);
        return 0;
    }

    char * grFile = new char[strlen(argv[1])+50];
    sprintf(grFile,"%s.rp",argv[1]);

    char * dictFile = new char[strlen(argv[1])+50];
    sprintf(dictFile,"%s.dict",argv[1]);

    FILE * grfp = fopen64(grFile,"r");
    my_fread(&min_value,sizeof(uint),1,grfp);
    my_fread(&max_value,sizeof(uint),1,grfp);
    my_fread(&max_assigned,sizeof(uint),1,grfp);
    my_fread(&m,sizeof(uint),1,grfp);
    my_fread(&n,sizeof(uint),1,grfp);
    uint nodes;
    my_fread(&nodes,sizeof(uint),1,grfp);
    symbols = new uint[++m];
    assert(symbols!=NULL);
    my_fread(symbols,sizeof(uint),m,grfp);

    fclose(grfp);
    max_value-=nodes;
    max_assigned-=nodes;

    symbols_pair = (uint*)malloc(sizeof(uint)*2*(max_assigned-max_value));
    assert(symbols_pair!=NULL);
    FILE * dictfp = fopen64(dictFile,"r");
    for(uint i=0;i<(max_assigned-max_value);i++) {
        uint nv, p1, p2;
        my_fread(&nv,sizeof(uint),1,dictfp);
        my_fread(&p1,sizeof(uint),1,dictfp);
        my_fread(&p2,sizeof(uint),1,dictfp);
        nv-=nodes; p1-=nodes; p2-=nodes;
        if(p1>=max_assigned || p2>=max_assigned || nv>max_assigned) {
            printf("Fatal error:\n");
            printf("p1 = %u\np2 = %u\nnv = %u\nmax_value = %u\n",p1,p2,nv,max_value);
            return -1;
        }
        if(nv!=(uint)(i+max_value+1)) {
            printf("Something is wrong\n");
            exit(-2);
        }
        symbols_pair[2*i]=p1;
        symbols_pair[2*i+1]=p2;
    }

    compress_pair_table();

    char * rpgraphFile = new char[strlen(argv[1])+50];
    sprintf(rpgraphFile,"%s.rpgraph",argv[1]);

    nbits=bits(symbols_new_bit_len+max_value+1);
    FILE * rpgrfp = fopen64(rpgraphFile,"w");
    my_fwrite(&min_value,sizeof(uint),1,rpgrfp);
    my_fwrite(&max_value,sizeof(uint),1,rpgrfp);
    my_fwrite(&max_assigned,sizeof(uint),1,rpgrfp);
    my_fwrite(&nbits, sizeof(uint),1,rpgrfp);
    my_fwrite(&m,sizeof(uint),1,rpgrfp);
    my_fwrite(&n,sizeof(uint),1,rpgrfp);
    uint wr = 0;
    while((wr+=fwrite(symbols+wr,sizeof(uint),1,rpgrfp))<(m/32*nbits+m%32*nbits/32+1));

    uint max_sn = 0;
    for(uint i=0;i<symbols_new_len;i++)
        max_sn = max(max_sn,symbols_new[i]);
    uint bits_sn = bits(max_sn);
    uint * csymb_n = new uint[symbols_new_len*bits_sn/W+1];
    for(uint i=0;i<symbols_new_len*bits_sn/W+1;i++) csymb_n[i]=0;
    for(uint i=0;i<symbols_new_len;i++)
        SetField(csymb_n, bits_sn, i, symbols_new[i]);
    delete [] symbols_new;
    my_fwrite(&bits_sn,sizeof(uint),1,rpgrfp);
    my_fwrite(&symbols_new_len,sizeof(uint),1,rpgrfp);
    my_fwrite(csymb_n,sizeof(uint),symbols_new_len*bits_sn/W+1,rpgrfp);
    BRR->save(rpgrfp);

    char * fname = new char[strlen(argv[1])+50];
    sprintf(fname,"%s.ptr",argv[1]);
    FILE * fp = fopen64(fname,"r");
    if(fp==NULL) {
        printf("Error opening %s\n",fname);
    }
    int r;
    uint edges;
    my_fread(&r,sizeof(int),1,fp);
    my_fread(&r,sizeof(uint),1,fp);
                                 // nodes
    my_fwrite(&r,sizeof(uint),1,rpgrfp);
    //cout << "r=" << r << endl;
    uint nodes_aux = r;
    my_fread(&edges,sizeof(uint),1,fp);
                                 // edges
    my_fwrite(&edges,sizeof(uint),1,rpgrfp);
    my_fread(&r,sizeof(uint),1,fp);
                                 // this is the max length of a list
    my_fwrite(&r,sizeof(uint),1,rpgrfp);
    //cout << "Edges:" << edges << endl;
    uint plen = bits(edges);
    uint ptrs_len = (nodes_aux+1)*plen/W+1;
    uint * ptrs = new uint[ptrs_len];
    //cout << "ptrs_len=" << ptrs_len << " sizeof(uint)="<<sizeof(uint) << endl;
    my_fread(ptrs,sizeof(uint),ptrs_len,fp);
    fclose(fp);

    uint * ptr2 = new uint[nodes+2];
    for(uint i=0;i<nodes+1;i++) {
        ptr2[i] = BR->rank(GetField(ptrs,plen,i))-1;
    }
    ptr2[nodes+1] = m;
    delete [] ptrs;
    delete BR;

    uint * pptrs = new uint[(m+1)/W+1];
    uint * noz = new uint[(nodes+1)/W+1];
    for(uint i=0;i<(m+1)/W+1;i++)
        pptrs[i] = 0;
    for(uint i=0;i<(nodes+1)/W+1;i++)
        noz[i] = 0;
    for(uint i=0;i<=nodes;i++) {
        bitset(pptrs,ptr2[i]);
        if(ptr2[i]!=ptr2[i+1])
            bitset(noz,i+1);
    }
    bitset(pptrs,m);

    BitRankW32Int * bptrs = new BitRankW32Int(pptrs, m+1, true, 20);
    BitRankW32Int * bnoz = new BitRankW32Int(noz, nodes+1, true, 20);

    bptrs->save(rpgrfp);
    bnoz->save(rpgrfp);
    delete [] ptr2;

    return 0;
}
